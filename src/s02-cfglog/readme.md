# Step 2 - App Configuration and Logging

We are going to build a program which outputs some messages via system logger.
A logger is a service provided by application cahssis - a **top level composition 
root** of any application. 

> We strongly recommend that you review [STEP 1 - Console CLI Application](/src/s01-console) first

## Overview

When you run the application:
```csharp
./out/Debug/$ dotnet s02-cfglog.dll
```

We are running the app with its [Default Config file](s02-cflog.laconf) which specifies a console log 
sink, so all log messages will be shown in the console.

The following output is produced:
 
<img src="img/screen01.png" height="500px">

Notice many "info" lines generated by the application host (chassis) which mounts all
of the services declared in a config. Notice the `app.ini` tag in console dump in the beginning
and then `app.cleanup` at the end.

A few messages in the middle are generated by the app code in the program file.

The [Program.cs](Program.cs) allocates app and then calls a few methods to demo logging:
```csharp
  using (var app = new AzosApplication(args))
  {
    log_direct_info(app);
    log_direct_correlation(app);
    log_direct_error(app);
    log_component(app);
    . . .
  }
```
The "direct" methods above are used just as an example of manual log message construction which 
you would **rarely (if ever) need in business applications** as most of the plumbing is going to 
be handled for you automatically by the "component loggers" as shown in `log_component` method.

The program declares a [`MyDemoComponent`](MyDemoComponent.cs) class which has no real
functionality but for a `Demonstrate()` method which uses **component logger**.

Component loggers add necessary information to log messages (entries) which allow for future
filtering and identification what **system/app/component/tracepoint generated every log entry**.
This is especially important in distributed cloud APM solutions which perform cross-application
cross-server aggregation of log data.

> Application components are logical building blocks mounted in application container. Most services 
> (e.g. a logger) are components. Components provide a uniform architectural pattern for 
> business and system logic in a well-structured and manageable way. For example, components 
> can be managed at runtime (e.g. sent commands) and changed some parameters (e.g. log level) 
> without the need to stop/re-start your application.
 
## Log Configuration
In the first section above we just created a simple logger which writes into console, however
we want to add other log sinks to get messages writen into a file, get detaile exception dumps etc.
We are going to create a few alternate config files which would allow us to use different log graph
whithout changing anything in the application code.

To run an application with a different config file:
```
./out/Debug/$ dotnet s02-cfglog.dll -config s02-cflog-files.laconf
```

This would use a different named file for app config. 




 
## Quick Q and A

### How to implement async logging?
Just call `ILog.Write(msg)` the logger is **async-first by design** your call returns synchronously
instantly.

### Why ILog.Write() does not return a Task? How do I await it?
You do not need to await the log write operation as it is asynchronous internally by design, that is:
it is **guaranteed to never block and return instantly to the caller** 

### Is logging thread-safe?
Yes it is. You can write from anywhere in parallel from threads/tasks/continuations etc.

### How do I use structured logging?
Use `Message.Parameters` - by convention use JSON with whatever structure you may need for later structured processing

### How can I see exception details? Console logger does not show it?
You need to use `DebugSink` just add it to the log graph and you will see detailed exception data
along with stack traces, codes etc... `ConsoleSink` is build for on-screen display only and is not meant
to be used for complex debugging traces

### I need to log into my custom database. How?
Create you own `Sink`, inject it in log graph using config type attribute referencing your sink, or add it
programmatically by code (no config)

### Is logger synchronous? Is sink asynchronous? Why no "tasks" in sinks?
By design. Defaul log daemon implementations are asynchrnous with a dedicated thread/queue.
Sinks are ALWAYS synchronous by design. You can use "LogSink" to spawn an inner sink with its own
asynchronous flow and graph

### Concerned with performance. Every log write allocates a `Message`?
Unless you have a need to constantly **log 100Ks messages a second per process for extended periods of time**
this is of no concern.  We use logging for full APM including business operation tracing
processing thousands of requests a second with very low CPU/GC overhead.

### How do I log into Dynatrace, Splunk, Datadog and other APMs?
You add a sink that sends data to those services. Azos logging is very detailed and can satisfy any APM tool

### What happens if sink goes bad? Does logging stop?
Every sink has an SLA and failover. If sink goes bad it can spill-over to its failover sink.
You can build complex graphs with many sinks, sub-chains with their own async pipe and this 
can get infinitly complex. Practice whos that logging to CSV text file and debug log file is very
stable and good practice.

### How do you delete old log files/reclaim space?
Use `DeleteFilesJob` (see above), which runs in a built-in scheduler daemon which drops files.
The `DeleteFilesJob` works with **virtual file system** so it can clean you **Amazon S3 buckets**, local files,
or whatever other fs you may want to work with.

### How do I archive old data?
Use `ArchiveLogSink` directed into a virtual file system. You can add **compression and AES encryption** as well.
The archive format in Azos was purposely designed for huge files and being able to navigate them even if they are partially corrupted.








